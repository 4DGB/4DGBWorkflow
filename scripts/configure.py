#!/usr/bin/env python3

#
# Given an input project directory, an output directory and the paths
# to some dependencies, generates a Ninja file to build a project bundled
# with the browser.
#
# Usage:
#   ./configure.py INPUT_DIR OUTPUT_DIR PATH_TO_BROWSER_REPO
#
# For this to work, we expect the script hic2structure.py to be in the PATH,
# as well as the LAMPPS executable, lmp. (And all required python modules should
# already be installed). This script is really only called inside the docker
# container, which ensures it's all set up properly, so it's not a problem.
#

import sys
from pathlib import Path
from shlex import quote
import typing as T
from typing import TypedDict
import json

import yaml
from yaml import Loader

import ninja_syntax as ninja

########################
# PARSE / LOAD ARGUMENTS
########################

# Parse arguments
if len(sys.argv) < 4:
    print("Usage: /configure.py INPUT_DIR OUTPUT_DIR PATH_TO_BROWSER_REPO")
    exit(1)
[ INDIR, OUTDIR, BROWSER_DIR ] = map(Path, sys.argv[1:4])

# Find project file
INDIR = INDIR.resolve()
search = [ INDIR.joinpath(f) for f in ['workflow.yaml', 'project.yaml'] ]
try:
    PROJECT_FILE = next( f for f in search if f.is_file() )
except StopIteration:
    print(f"Could not find project file. (Looked for '{search[0]}' and '{search[1]}')")
    exit(1)

# Load project file
with open(PROJECT_FILE, 'r') as f:
    SPEC = yaml.load(f, Loader=Loader)

# Output directory
OUTDIR = OUTDIR.resolve()

########################
# PARSE PROJECT SPEC
########################

# 'Hic' represents an input Hi-C file alongside the files it will output
# when processed
Hic = TypedDict('HicFile', index=int, name=str, path=Path, outdir=Path, outfiles=T.List[Path])
def parse_hic(t: T.Tuple[int, T.Dict]) -> Hic:
    outdir = OUTDIR.joinpath(f"lammps_{t[0]}")
    return {
        'index': t[0],
        'name': t[1]['name'],
        'path': INDIR.joinpath(t[1]['data']).resolve(),
        'outdir': outdir,
        'outfiles': [ outdir.joinpath('out', f) for f in 
            ['structure.csv', 'contactmap.tsv']
        ]
    }

HIC_FILES = list(map( parse_hic, enumerate(SPEC['datasets']) ))

# A list of the data files related to array/track data
TRACK_DATA_FILES = set()
if 'tracks' in SPEC:
    for track in SPEC['tracks']:
        # Each track has an extra json file associated with it
        trackfile = Path(track['data'])
        TRACK_DATA_FILES.add(trackfile)

        # That extra file specifies the locations of the acutal
        # array data files
        trackfile_path = INDIR.joinpath(trackfile)
        with open(trackfile_path, 'r') as f:
            trackmeta = json.load(f)
            for data in trackmeta['data']['values']:
                TRACK_DATA_FILES.add(data['url'])

PROJECT_SPEC = SPEC['project']
INTERVAL   = PROJECT_SPEC.get('interval', 200000)
CHROMOSOME = PROJECT_SPEC.get('chromosome', 'X')
THRESHOLD  = PROJECT_SPEC.get('threshold', 2.0)

########################
# WRITE NINJA FILE
########################

OUTDIR.mkdir(exist_ok=True)
with open(OUTDIR.joinpath("build.ninja"), 'w') as f:

    ########################
    # WRITE NINJA RULES
    ########################

    WRITER = ninja.Writer(f, width=120)
    WRITER.comment("Build file generated by configure.py. DO NOT edit by hand!")

    # Run LAMMPS
    WRITER.rule(
        'lammps', f'hic2structure.py -v -r {quote(str(INTERVAL))} -c {quote(str(CHROMOSOME))} -t {quote(str(THRESHOLD))}'
        ' --output ${out}/out --directory $out $in',
                # ðŸ‘† this part isn't a python formatter, it's for Ninja
        description="Run LAMMPS Simulation"
    )

    # Generate project.json
    project_json_script = quote(str(
        Path(__file__).parents[0].joinpath("project_yaml2json.py").resolve()
    ))
    WRITER.rule(
        'project', f'"{project_json_script}" "$in" "{quote(str(OUTDIR))}"',
        description="Generate project.json"
    )

    # Copy files into output directory
    WRITER.rule(
        'copytodir', f'cp -rt "{quote(str(OUTDIR))}" $in',
        description="Copy files into project directory"
    )

    # Plain ol' file copy
    WRITER.rule(
        'copy', 'cp $in $out',
        description="Copy file"
    )

    # Generate SQLite Database
    dbpop_script = quote(str(
        BROWSER_DIR.joinpath('bin', 'db_pop')
    ))
    server_dir = quote(str(
        BROWSER_DIR.joinpath('server')
    ))
    WRITER.rule(
        'dbpop', f'python3 "{dbpop_script}" "{quote(str(OUTDIR))}" "{server_dir}"',
                                            # ðŸ‘†-project output directory
        description="Generate project database"
    )

    ########################
    # WRITE NINJA BUILDS
    ########################

    # LAMMPS builds
    for hic in HIC_FILES:
        WRITER.build(
            outputs=str(hic['outdir']),
            implicit_outputs=[
                str(path) for path in hic['outfiles']
            ],
            rule='lammps',
            inputs=str(hic['path'])
        )

    # Generate project.json
    project_json = OUTDIR.joinpath('project.json')
    WRITER.build(
        outputs=str(project_json),
        implicit=str(project_json_script),
        inputs=str(PROJECT_FILE.resolve()),
        order_only=[
            str(path) for h in HIC_FILES for path in h['outfiles']
        ],
        rule='project'
    )

    # Copy track data
    for file in TRACK_DATA_FILES:
        inpath = INDIR.joinpath(file)
        outpath = OUTDIR.joinpath(file)
        WRITER.build(
            outputs=str(outpath),
            rule='copy',
            inputs=str(inpath)
        )

    # Generate database
    WRITER.build(
        outputs=str(OUTDIR.joinpath('generated')),
        implicit=[str(dbpop_script), str(BROWSER_DIR.joinpath('server','version.md'))],
        inputs=str(project_json),
        rule='dbpop'
    )
